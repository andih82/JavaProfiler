import java.math.BigDecimal;
class _M {  // class for recording measurements

    //----- metadata initialized in init metho
    static String[] classNames;    // class names
    static String[][] methodNames;    // method names
    static long overalltime;
    static long[][] time;    // run times of methods
    static long[][] corr;    // correction of run times for each method

    //----- stacks and current values
    static int[] classes;    // stack of class numbers
    static int[] methods;    // stack of method numbers
    static long[] times;    // stack of times
    static int top = 0;    // stack pointer

    static int curClass = -1;    // current class number
    static int curMethod = -1;    // current method number


    public static void beg(int c, int m) {
        classes[top] = curClass;
        methods[top] = curMethod;
        times[top] = System.nanoTime();  // record start time
        top++;
        curClass = c;
        curMethod = m;
    }

    public static void end() {
        top--;
        long currTime = System.nanoTime() - times[top];  // compute run time of current method
        time[curClass][curMethod] += currTime;
        // only correct if not root method, else ste overalltime
        if (top == 0) {
            overalltime = System.currentTimeMillis() - overalltime;
            return;
        }
        curClass = classes[top];
        curMethod = methods[top];
        corr[curClass][curMethod] += currTime;
    }

    public static void unrollTo(int c, int m) {
        while (curClass != c || curMethod != m) end();
    }

    public static void init() {
        //----- metadata initialized by instrumenter
        classNames = new String[]{%classArray%};
        methodNames = new String[][]{
                %methodArrays%
        };
        time = new long[classNames.length][];
        corr = new long[classNames.length][];
        for (int i = 0; i < classNames.length; i++) {
            time[i] = new long[methodNames[i].length];
            corr[i] = new long[methodNames[i].length];
        }

        //----- creation of stacks
        classes = new int[1000];
        methods = new int[1000];
        times = new long[1000];

        //-------- starttime
        overalltime = System.currentTimeMillis();
    }

    public static void printResults() {
        System.out.println("\n----- Results: ");
        System.out.println("Overall time: " + overalltime + " millis");

        int nameLength = 0;
        int timeLength = 8;
        for (int i = 0; i < classNames.length; i++) {
            for (int j = 0; j < methodNames[i].length; j++) {
                int tmpLength = (classNames[i] + methodNames[i][j]).length();
                int tmpTimel = ("" + time[i][j]).length();
                if (tmpLength > nameLength) nameLength = tmpLength;
                if (tmpTimel > timeLength) timeLength = tmpTimel;
            }
        }
        nameLength += timeLength;
        String formatString = "%-" + (nameLength) + "s %" + timeLength + ".3f ms %" + timeLength + ".3f ms %" + timeLength + ".3f ms \n";
        System.out.printf("%-" + (nameLength) + "s    %" + timeLength + "s    %" + timeLength + "s    %" + timeLength + "s \n", "", "time", " subMethod", "corrected");
        long sumCorrected = 0;
        for (int i = 0; i < classNames.length; i++) {
            for (int j = 0; j < methodNames[i].length; j++) {
                sumCorrected += (time[i][j] - corr[i][j]);
              //  System.out.printf(formatString, classNames[i] + "." + methodNames[i][j], time[i][j] / 1000, corr[i][j] / 1000, (time[i][j] - corr[i][j]) / 1000);
                System.out.printf(formatString, classNames[i] + "." + methodNames[i][j],
                 new BigDecimal(time[i][j]).movePointLeft(6) , new BigDecimal( corr[i][j]).movePointLeft(6), new BigDecimal((time[i][j] - corr[i][j]) ).movePointLeft(6));
            }
        }
        System.out.printf("%-" + (nameLength + (3 * timeLength)) + "s%" + (timeLength -1) + ".3f ms" , "", new BigDecimal(sumCorrected).movePointLeft(6));

        System.out.printf("\n\nOverall/Corrected:  %d/%d ms \n\n\n", overalltime, sumCorrected / 1000000);
    }
}